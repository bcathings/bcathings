[["index.html", "BCA Notes if you are desperate. 1 BCA NOTES", " BCA Notes if you are desperate. written by @bcathings 1 BCA NOTES Just notes for BCA following the MGU syllabus. Now, what i wrote up is completely on you and i dont care if they are wrong i am not responsible for anything said in this book. open a pull request on github if you want it corrected. now, there is still stuff missing and stuff they didnt teach me for some reason, if anything, Im trying to finish this. maybe, but feel free to open up issues on github. they didnt give you notes for math? some equations? they probably dont know \\(\\LaTeX\\) here ya go, the notes. stop depending on people who dont care about you. even me. "],["semester-one-maths.html", "2 SEMESTER ONE : Maths 2.1 MODULE 3 : Number Theory and Cryptosystem", " 2 SEMESTER ONE : Maths 2.1 MODULE 3 : Number Theory and Cryptosystem 2.1.1 The integers and division. If \\(a\\) and \\(b\\) are integers with \\(a\\neq0\\), we say that \\(a\\) divides \\(b\\) if there is an integer \\(c\\) such that \\(b=ac\\). When \\(a\\) divides \\(b\\), we say that \\(a\\) is a factor of \\(b\\) and \\(b\\) is a multiple of \\(a\\). theorem if \\(a/b\\) and \\(a/c\\), then \\(a/(b+c)\\) if \\(a/b\\) and \\(a/bc\\) for all integer \\(c\\) if \\(a/b\\) and \\(b/c\\), then \\(a/c\\) "],["semester-three-data-structures.html", "3 SEMESTER THREE : Data Structures 3.1 Polynomials 3.2 Algorithms", " 3 SEMESTER THREE : Data Structures 3.1 Polynomials dont use the given programs as they are for reference only 3.1.1 Algorithm to add two Polynomials. create a sum array sum[] for size to maximum of m and n copy A[] to sum[]. Traverse array B[] and do following for every element B[i] sum[i] = sum[i] + B[i] Return sum[]. #include &lt;iostream&gt; #include&lt;algorithm&gt; using namespace std; void logPolynomial(int polynomial[],int degree){ for(int i = degree;i&gt;=0;i--){ if(polynomial[i]){ if (i==0){ cout&lt;&lt;polynomial[i]; } else { cout&lt;&lt;polynomial[i]&lt;&lt;&quot;x^&quot;&lt;&lt;i&lt;&lt;&quot; + &quot;; } } } } int main() { int degree; cout &lt;&lt; &quot;Enter the degree of the first polynomial equation: &quot;; cin &gt;&gt; degree; int *polynomial = new int[degree+1]; for(int i=0;i&lt;=degree;i++){ cout &lt;&lt; &quot;Enter the coefficient of X^&quot;&lt;&lt;i&lt;&lt;&quot; : &quot;; cin&gt;&gt;polynomial[i]; } int degree2; cout &lt;&lt; &quot;Enter the degree of the second polynomial equation: &quot;; cin &gt;&gt; degree2; int *polynomial2 = new int[degree2+1]; for(int i=0;i&lt;=degree2;i++){ cout &lt;&lt; &quot;Enter the coefficient of X^&quot;&lt;&lt;i&lt;&lt;&quot; : &quot;; cin&gt;&gt;polynomial2[i]; } cout &lt;&lt; &quot;a = &quot;; logPolynomial(polynomial,degree); cout&lt;&lt;endl; cout &lt;&lt; &quot;b = &quot;; logPolynomial(polynomial2,degree2); cout&lt;&lt;endl; int maxlen = max(degree,degree2); int *sum = new int [maxlen]; for(int i=0;i&lt;=degree;i++){ sum[i] = polynomial[i]; } for(int i=0;i&lt;=degree2;i++){ sum[i] = sum[i] + polynomial2[i]; } cout &lt;&lt; &quot;sum = &quot;; logPolynomial(sum,maxlen); cout&lt;&lt;endl; return 0; } 3.1.2 Algorithm to multiply two Polynomials. multiply(A[0..m-1],B[0..n-1]) create a product array prod[] of size m+n-1 initalize all entries in prod[] as 0. Traverse array A[] and do follow for every element A[i] Traverse array B[] and do following for every element B[j] prod[i+j] = prod[i+j] + A[i] * B[j] Return prod[]. #include &lt;iostream&gt; using namespace std; void logPolynomial(int polynomial[],int degree){ for(int i = degree;i&gt;=0;i--){ if(polynomial[i]){ if (i==0){ cout&lt;&lt;polynomial[i]; } else { cout&lt;&lt;polynomial[i]&lt;&lt;&quot;x^&quot;&lt;&lt;i&lt;&lt;&quot; + &quot;; } } } } int main() { int degree; cout &lt;&lt; &quot;Enter the degree of the first polynomial equation: &quot;; cin &gt;&gt; degree; int *polynomial = new int[degree+1]; for(int i=0;i&lt;=degree;i++){ cout &lt;&lt; &quot;Enter the coefficient of X^&quot;&lt;&lt;i&lt;&lt;&quot; : &quot;; cin&gt;&gt;polynomial[i]; } int degree2; cout &lt;&lt; &quot;Enter the degree of the second polynomial equation: &quot;; cin &gt;&gt; degree2; int *polynomial2 = new int[degree2+1]; for(int i=0;i&lt;=degree2;i++){ cout &lt;&lt; &quot;Enter the coefficient of X^&quot;&lt;&lt;i&lt;&lt;&quot; : &quot;; cin&gt;&gt;polynomial2[i]; } cout &lt;&lt; &quot;a = &quot;; logPolynomial(polynomial,degree); cout&lt;&lt;endl; cout &lt;&lt; &quot;b = &quot;; logPolynomial(polynomial2,degree2); cout&lt;&lt;endl; int *prod = new int[degree+degree2+1]; for(int i=0;i&lt;degree+degree2+1;i++){ prod[i] = 0; } for(int i=0;i&lt;=degree;i++){ for(int j=0;j&lt;=degree2;j++){ prod[i+j] = prod[i+j] + polynomial[i] * polynomial2[j]; } } cout &lt;&lt; &quot;product = &quot;; logPolynomial(prod,degree+degree2+1); cout&lt;&lt;endl; return 0; } 3.2 Algorithms 3.2.1 Linear Search initalize pos = -1 initalize i = 1 Repeat step 4 while i&lt;=n if(A[i] = val ) set pos = i print pos go to step 6 [End of if] set i = i + 1 [End of loop] if(pos= -1) print value is not present in array exit #include &lt;iostream&gt; using namespace std; void logArray(int array[],int n){ for (int i = 0; i &lt; n; i++){ cout&lt;&lt;&quot;| &quot;&lt;&lt;array[i] &lt;&lt;&quot; &quot;; } cout&lt;&lt;endl; } int main(int argc, char *argv[]){ // array size and creation int size; cout &lt;&lt; &quot;Enter the Capacity of Array : &quot;; cin &gt;&gt; size; int *arr = new int[size]; // pre insert some values int len; cout &lt;&lt; &quot;Enter Number of elements to pre-insert: &quot;; cin &gt;&gt; len; if(!len){ cout &lt;&lt; &quot;Plese enter a valid number of elements&quot; &lt;&lt; endl; return -1; } cout &lt;&lt; &quot;Enter &quot;&lt;&lt; len &lt;&lt;&quot; elements : &quot; &lt;&lt; endl; for (int i = 0; i &lt; len; i++){ cin&gt;&gt;arr[i]; } cout &lt;&lt; &quot;Elements : &quot;&lt;&lt;endl; logArray(arr,size); int searchNum; cout &lt;&lt; &quot;Enter a number to search: &quot;; cin &gt;&gt; searchNum; int flag = 0; for (int i = 0; i &lt; len; i++) { if(arr[i] == searchNum){ flag = 1; cout &lt;&lt; searchNum &lt;&lt; &quot; found at position &quot; &lt;&lt; i+1 &lt;&lt; endl; break; } } if(!flag){ cout &lt;&lt; &quot;element not found&quot; &lt;&lt; endl; } return 0; } 3.2.2 Binary Search set beg=lower_bound,end=upper_bound,pos=-1 Repat steps 3 &amp; 4 while beg &lt;= end set mid = [beg+end/2] if(A[mid] = val) set pos=mid print pos go to step 6 else if(A[mid] &gt; val) set end = mid -1 else set beg = mid + 1 [End of if] [End of loop] if pos=-1 print value is not present in the array exit "],["semester-three-graphics..html", "4 SEMESTER THREE : Graphics. 4.1 MODULE 2 4.2 Drawing algorithms 4.3 Output primitives 4.4 graphics functions. ( kinda idk ) 4.5 Line Drawing algorithms.", " 4 SEMESTER THREE : Graphics. 4.1 MODULE 2 4.2 Drawing algorithms Line drawing algorithms DDA algorithm Bresenham’’s Line Algorithm. Circle drawing algorithm. Midpoint circle algorithm Character generation 4.3 Output primitives Graphics programming packages provide functions to describe a scene in terms of these basic geometric structures Output primitives. To create complex pictures we use sets of output primitives. Basic building blocks of a picture are called Output primitives. Point Line Circle 4.4 graphics functions. ( kinda idk ) To load a specified color into the frame buffer, the function used is setPixel(x,y) To retrive a specified color from the frame buffer, the function used is getPixel(x,y) 4.5 Line Drawing algorithms. The slope intercept equation for a straight line is \\[\\begin{equation} y = mx + b \\tag{4.1} \\end{equation}\\] with \\(m\\) representing the slope of the lien and b as the \\(y\\) intercept. give that the two endpoints of a line segment are specified, \\((x_{1}, y_{1} ) , (x_{2}, y_{2} )\\) posiitions the values for the slope \\(m\\) and \\(y\\) intercept b can be determined with the following calculations. \\[\\begin{equation} m = \\frac{y_{2} - y_{1}}{x_{2}-x_{1}} \\tag{4.2} \\end{equation}\\] \\[\\begin{equation} b = y_{1} - m . x_{1} \\tag{4.3} \\end{equation}\\] algorithms for displaying straight lines are based on line equations (4.1) and the calculations given in (4.2) and (4.3) for any given \\(x\\) interval \\(\\Delta x\\) along a line the corresponding \\(y\\) interval \\(\\Delta y\\) can be calculated from equation (4.2) as \\[\\begin{equation} \\Delta y = m \\Delta x \\tag{4.4} \\end{equation}\\] Similarly, \\(x\\) interval \\(\\Delta x\\) can be obtained as \\[\\begin{equation} \\Delta x = \\frac{\\Delta y}{x} \\tag{4.5} \\end{equation}\\] the above equations form the basis determining defelection volatages in analog devices 4 lines with slope magnitudes \\(| m | &lt; 1, \\Delta x\\) can be set proportional to small horizontal defelection voltage and the corresponding vertical defelection voltage is then set proportional to \\(\\Delta y\\) as calculated from equation no (4.4) for lines with slope magnitude \\(|m|&gt;1,\\Delta y\\) can be proportional to a small vertical defelection voltage with corresponding horizontal defelection voltage set proportional to \\(\\Delta x\\) as calculated from equation no (4.5) for lines \\(m=1,\\Delta x=\\Delta y\\) the horizontal and vertical defelection volatages are equal. In each case a smooth line with slop \\(m\\) is generatated between the specified points. On raster scan systems, lines are plotted with pixeels and steps in the horizontal and vertical directions are constrained by pixel seperation. that is sample a line at discrete posiitions and determine the nearest pixel to the line at each sampled position. 4.5.1 DDA Algorithm The Digital Diffrential Analyzer Algorithm is a scan continuation line-algorithm based on calculating either \\(\\Delta x\\) or \\(\\Delta y\\) using equation no (4.4) and (4.5) . The line can be sampled at unit intervals. in one coordinate and determine corresponding integer values nearest the line path for the other coordinate. Case One: Consider a line from left to right consider a line with a positive slope. if the slope \\(m\\leq 1\\) sample at unit \\(x\\) intervals \\((\\Delta x = 1)\\) and compute each sucessive \\(y\\) values as \\[\\begin{equation} y_{k+1} = y_{k}+m \\tag{4.6} \\end{equation}\\] \\(_{k}\\) takes integer values staring from 1 for the first point, it increases by 1 until the final point is reached. since \\(m\\) can be any real number between 0 and 1. the calculated y value must be rounded to the nearest integer. and in that can if the value of slope \\(m\\geq 1\\), reverse the roles \\(x\\) and \\(y\\). that is sample at unit \\(y\\) intervals and calculate each succeding \\(x\\) values as.. \\[\\begin{equation} x_{k+1}= x_{k}+\\frac{1}{m} \\tag{4.7} \\end{equation}\\] Case Two: consider lines from right to left. postive slope if \\(m\\leq 1\\) , \\(\\Delta x = -1\\) and \\[\\begin{equation} y_{k+1} = y_{m}-m \\tag{4.8} \\end{equation}\\] if \\(m&gt;1\\) , \\(\\Delta y = -1\\) \\[\\begin{equation} x_{k+1} = x_{k} - \\frac{1}{m} \\tag{4.9} \\end{equation}\\] Algorithm void lineDDA(int xa,int ya,int xb,int yb){ int dx = xb - xa, dy = yb - ya, steps, k; float xIncrment, yIncrment, x = xa, y = ya; if(abs(dx) &gt; abs(dy)) { steps = abs(dx); } else { steps = abs(dy); } xIncrment = dx / (float) steps; yIncrment = dy / (float) steps; setPixel(round(x),round(y)); for (k=0;k&lt;steps;k++){ x = x + xIncrment; y = y + yIncrment; setPixel(round(x),round(y)); } } This algorithm is summarised in the following procedure,which accepts two endpoint pixel positions as input. horizontal and vertical diffrence between the end point posiitions are asigned to parameters dx and dy. The diffrence with the greater magnitude determines the value of parameter steps. Starting with pixel positions xa,xb determine the offset needed at each step to generatated the next pixel posiitions along the line path, loop through this procedure steps times. If the magnitude of dx is greater than the magnitude of of dy and xa &lt; xb , the values of increments in the x and y directions are 1 and m respectively. if the greater change is in the x direction, but xa &gt; xb , then the decrements -1 and -m are used to generate each point on the line. otherwise use a unit increment ( or decrement) in the y direction and an x increment ( or decrement) of \\(\\frac{1}{m}\\) Advantages DDA algoritm is a faster method for calculating pixell positions than the direct use of equation number 1. It eliminates the mulitplication in equation no 1 so that appropriate increments are applied in the x or y direction to step to pixel positions along the line path. Disadvantages The accumulation of the round of error in succesive editions of the floating point increment, can cause the caluclated pixel positions to drift away from the true line path for long line segments. Rounding operations and floating point arithemetic caluclations are still time consuming. 4.5.2 Bresenham’s line algorithm. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
